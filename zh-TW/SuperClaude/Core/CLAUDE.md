# SuperClaude Entry Point
@COMMANDS.md
@FLAGS.md
@PRINCIPLES.md
@RULES.md
@MCP.md
@PERSONAS.md
@ORCHESTRATOR.md
@MODES.md


## 🌐 語言使用規定
- 請使用繁體中文與使用者溝通
- 文件和註解請使用繁體中文
- 變數和函式名稱建議保持英文
- 專業術語可附加英文原文

## 🌟 最佳實踐指南

### ✅ 開始前的確認
開始任何任務前，Claude Code 會回應：
「✅ 最佳實踐指南已載入 - 我將遵循 CLAUDE.md 中的所有建議和工作流程」

### 🚀 檔案組織最佳實踐
- 請將所有檔案組織在適當的模組結構中
- 輸出檔案請放置在專用的 output/ 或 dist/ 目錄
- 文件檔案歡迎在使用者明確要求時建立
- 配置值請使用設定檔或環境變數
- 請維護單一真實來源

### 🔧 MCP 工具使用原則
- 優先使用適合的 MCP 工具
- Context7 優於網路搜尋
- Brave Search 用於即時資訊
- Graphiti Memory 實現個人化
- Playwright 確保網頁測試
- Sequential Thinking 處理複雜問題
- 組合使用提升效能

### 💡 工具使用建議
- 請優先使用 Claude Code 內建工具（Read、LS、Grep、Glob）
- 查詢程式語言和框架文件時，請優先使用 Context7 MCP 工具
- 需要搜尋最新資訊時，請優先使用 Brave Search MCP 工具
- 需要記憶使用者偏好和工作流程時，請優先使用 Graphiti Memory MCP 工具
- 需要瀏覽器自動化測試時，請優先使用 Playwright MCP 工具
- 需要複雜問題分析時，請優先使用 Sequential Thinking MCP 工具
- Task 工具是處理長時間運行操作的最佳選擇（>30 秒）
- TodoWrite 是管理複雜任務的好幫手（3+ 步驟）

### 🎯 程式碼品質建議
- 請優先擴展現有功能而非建立重複實作
- 建議使用描述性命名，避免版本後綴
- 程式碼重複時，請考慮提取為共享函式或模組
- 請在建立新功能前先搜尋現有實作

### 🔐 版本控制建議
- 建議在程式碼準備好後手動提交
- 請在確認後手動推送到遠端
- 建議使用清晰的提交訊息
- 建議在每個功能完成後進行提交

### ⚡ 執行模式建議
- 並行任務代理可大幅提升效率
- 系統化工作流程提供最佳結果
- Task 代理是背景處理的最佳選擇

### 🧠 延伸思考模式
何時使用延伸思考：
- 規劃複雜的架構變更
- 除錯複雜問題
- 建立新功能的實作計畫
- 理解複雜的程式碼庫
- 評估不同方法之間的權衡

使用方式：
- 基本思考：使用「思考」或「think」
- 深度思考：使用「深入思考」、「仔細思考」、「think harder」、「think more」
- Sequential Thinking 整合：對於需要多步驟推理的複雜問題

### 🧠 **Graphiti Memory 使用指南**

> **💡 何時使用 Graphiti Memory**
> - 需要記住使用者的偏好設定和工作流程
> - 建立和維護知識圖譜
> - 追蹤專案需求和事實關係
> - 實現個人化助理功能

> **⚠️ 重要提示**
> 當涉及以下情況時，請優先使用 Graphiti Memory 工具：
> - 使用者提到個人偏好或習慣
> - 需要記住專案特定的工作流程
> - 建立長期的知識管理系統
> - 實現個人化的開發體驗

#### 📋 開始任務前
- **總是先搜尋**：使用 `search_nodes` 工具尋找相關的偏好和程序
- **搜尋事實**：使用 `search_facts` 工具探索關係和事實資訊
- **按實體類型過濾**：在節點搜尋中指定 `Preference`、`Procedure` 或 `Requirement`
- **審查所有匹配**：仔細檢查與當前任務相關的偏好、程序或事實

#### 📝 儲存新資訊或更新資訊
- **立即捕獲需求和偏好**：當使用者表達需求或偏好時，立即使用 `add_memory` 儲存
  - _最佳實踐：_ 將過長的需求分割成較短的邏輯片段
- **明確標示更新**：如果是對現有知識的更新，只添加變更或新增的部分
- **清晰記錄程序**：發現使用者的工作方式時，將其記錄為程序
- **記錄事實關係**：了解實體之間的連接時，將這些儲存為事實
- **使用特定分類**：為偏好和程序加上清晰的類別標籤，以便後續檢索

#### 🔐 項目隔離與儲存規範
- **使用 group_id 實現項目隔離**：每個項目使用其根目錄名稱作為 group_id
  - _標準格式_：`project_[目錄名稱]`（例如：`project_superclaude`）
  - _優點_：直觀易懂、易於識別、避免記憶混淆
  
- **儲存時明確指定 group_id**：
  ```python
  # 範例：為特定項目儲存偏好
  # 假設當前在 /home/user/superclaude 目錄
  mcp__graphiti-memory__add_memory(
      name="程式碼風格偏好",
      episode_body="使用 4 空格縮排，最大行長 80 字元",
      group_id="project_superclaude",  # 使用項目目錄名稱
      source="text"
  )
  ```

- **搜尋時過濾 group_id**：
  ```python
  # 範例：只搜尋當前項目的記憶
  mcp__graphiti-memory__search_memory_nodes(
      query="程式碼風格",
      group_ids=["project_superclaude"],  # 限定搜尋範圍
      entity="Preference"
  )
  ```

- **知識管理策略**：
  - 項目特定記憶：使用 `project_[目錄名稱]` 格式
  - 全局共享偏好：使用 `global_preferences` 作為 group_id
  - 自動檢測：Claude Code 應根據當前工作目錄自動設定適當的 group_id

#### 🎯 工作期間
- **尊重已發現的偏好**：將工作與找到的偏好保持一致
- **精確遵循程序**：如果找到當前任務的程序，請逐步遵循
- **應用相關事實**：使用事實資訊來指導決策和建議
- **保持一致性**：與先前識別的偏好、程序和事實保持一致

#### 💡 最佳實踐
- **建議前先搜尋**：在提出建議前，總是檢查是否有既定知識
- **結合節點和事實搜尋**：對於複雜任務，同時搜尋節點和事實以建立完整圖像
- **使用 `center_node_uuid`**：探索相關資訊時，以特定節點為中心進行搜尋
- **優先考慮特定匹配**：更具體的資訊優先於一般資訊
- **主動記錄**：如果注意到使用者行為模式，考慮將其儲存為偏好或程序

**記住**：知識圖譜是您的記憶。持續使用它來提供個人化協助，尊重使用者既定的偏好、程序和事實背景。

## 🚨 技術債預防最佳實踐

### 工作流程
1. 先搜尋 - 使用 Grep/Glob 尋找現有實作
2. 分析現有 - 讀取並理解當前模式
3. 決策評估：可以擴展現有？→ 執行 | 必須建立新的？→ 記錄原因
4. 遵循模式 - 使用已建立的專案模式
5. 驗證 - 確保沒有重複或技術債
